src/components/fade.tsx

```ts
import Vide, { Derivable, read, source } from "@rbxts/vide";

type FadeProps = {
	name?: string;
	groupColor?: Derivable<Color3>;
	groupTransparency?: Derivable<number>;
	anchor?: Derivable<Vector2>;
	position?: Derivable<UDim2>;
	size?: Derivable<UDim2>;
	rotation?: Derivable<number>;
	zIndex?: Derivable<number>;
	layoutOrder?: Derivable<number>;
	events?: Vide.InstanceEventAttributes<Frame>;
	before?: () => Vide.Node;
	children?: Vide.Node;
	parent?: Instance;
};

export default function FadeComponent(props: FadeProps) {
	const frameRef = source<Frame>();
	const canvasGroupRef = source<CanvasGroup>();

	const transitioning = () => {
		const color = read(props.groupColor) || new Color3(1, 1, 1);
		const transparency = read(props.groupTransparency) ?? 0;

		return transparency > 0.01 || color !== new Color3(1, 1, 1);
	};

	<frame
		BackgroundTransparency={1}
		Size={new UDim2(1, 0, 1, 0)}
		Parent={() => (transitioning() ? canvasGroupRef() : frameRef())}
	>
		{props.children}
	</frame>;

	return (
		<frame
			Name={props.name ?? "Transition"}
			BackgroundTransparency={1}
			AnchorPoint={props.anchor}
			Size={props.size || new UDim2(1, 0, 1, 0)}
			Position={props.position}
			Rotation={props.rotation}
			LayoutOrder={props.layoutOrder}
			ZIndex={props.zIndex}
			Parent={props.parent}
			{...props.events}
		>
			<canvasgroup
				action={canvasGroupRef}
				GroupTransparency={props.groupTransparency}
				GroupColor3={props.groupColor}
				BackgroundTransparency={1}
				Size={new UDim2(1, 0, 1, 0)}
			>
				{props.before?.()}
			</canvasgroup>

			<frame
				action={frameRef}
				ClipsDescendants
				BackgroundTransparency={1}
				Size={new UDim2(1, 0, 1, 0)}
			>
				{props.before?.()}
			</frame>
		</frame>
	);
}
```

---

src/contexts/app.ts

```ts
// Packages
import { context } from "@rbxts/vide";

// Types
import type { Args } from "@root/decorators";

const AppContext = context<Args | undefined>(undefined);

export default AppContext;
```

---

src/contexts/childApp.ts

```ts
// Packages
import { context } from "@rbxts/vide";

// Types
import type { ChildArgs } from "@root/decorators";

const AppContext = context<ChildArgs | undefined>(undefined);

export default AppContext;
```

---

src/contexts/index.ts

```ts
export { default as ChildAppContext } from "./childApp";
export { default as AppContext } from "./app";
```

---

src/decorators/app.ts

```ts
// Types
import type Types from "@root/types";

// Dependencies
import { AppRegistry } from "@registries/apps";

export default function App<N extends AppNames>(props: Types.Decorator.AppProps<N>) {
	return function <T extends Types.Decorator.Constructor<N>>(constructor: T) {
		const groupKey = props.group ?? "None";

		// Ensure uniqueness
		if (AppRegistry.get(props.name)?.has(groupKey)) {
			error(
				`Duplicate registered App name "${props.name}" in same Group "${groupKey}". ` +
					`App names must be globally unique.`,
				2,
			);
		}

		if (!props.name) error("App registration failed: missing app name", 2);

		// Initialize registry map if missing
		if (!AppRegistry.has(props.name)) AppRegistry.set(props.name, new Map());

		const fadeConfig = (constructor as Types.Fade.Constructor).__forge_fade;

		// Register app
		AppRegistry.get(props.name)!.set(groupKey, {
			constructor,
			name: props.name,
			group: props.group,
			visible: props.visible,
			rules: props.rules,
			fade: fadeConfig,
		} as Types.Decorator.Entry<N>);

		return constructor;
	};
}
```

---

src/decorators/args.ts

```ts
// Packages
import Vide, { source, Source } from "@rbxts/vide";

// Types
import type { AppForge } from "@root/forge";
import type Types from "@root/types";

// Helpers
import getAppSource from "@helpers/getAppSource";

// Hooks
import { px, screen } from "@hooks/usePx";

abstract class BaseArgs {
	public readonly forge: AppForge;
	public readonly props: Types.Props.Class;

	public readonly name: AppNames;
	public readonly group: AppGroups;

	public readonly source: Source<boolean>;

	protected constructor(
		entry: Types.Decorator.Entry | Types.Decorator.ChildEntry,
		props: Types.Props.Main,
	) {
		this.name = entry.name;
		this.group = entry.group ?? "None";

		this.source = getAppSource(this.name, this.group);
		this.forge = props.forge;

		this.props = {
			...props.props,

			screen,
			px,
		};
	}

	abstract render(): AppForge.AppNode;
}

export abstract class Args extends BaseArgs {
	constructor(entry: Types.Decorator.Entry, props: Types.Props.Main) {
		super(entry, props);
	}
}
export abstract class ChildArgs extends BaseArgs {
	public readonly childrenSources = (): Source<boolean>[] => [source(false)];
	public readonly closeChildren = () => {};

	public readonly parentSource: Source<boolean>;

	constructor(entry: Types.Decorator.ChildEntry, props: Types.Props.Main) {
		super(entry, props);

		this.parentSource = getAppSource(entry.rules?.parent!, entry.rules?.parentGroup!);
	}
}
```

---

src/decorators/childApp.ts

```ts
// Types
import type Types from "@root/types";

// Dependencies
import { AppRegistry } from "@registries/apps";

export default function ChildApp<N extends AppNames>(props: Types.Decorator.ChildAppProps<N>) {
	return function <T extends Types.Decorator.ChildConstructor<N>>(constructor: T) {
		const groupKey = props.group ?? "None";

		// Ensure uniqueness
		if (AppRegistry.get(props.name)?.has(groupKey)) {
			error(
				`Duplicate registered App name "${props.name}" in same Group "${groupKey}". ` +
					`App names must be globally unique.`,
				2,
			);
		}

		if (!props.name) error("App registration failed: missing app name", 2);

		// Initialize registry map if missing
		if (!AppRegistry.has(props.name)) AppRegistry.set(props.name, new Map());

		// Register app
		AppRegistry.get(props.name)!.set(groupKey, {
			constructor,
			name: props.name,
			group: props.group,
			visible: props.visible,
			rules: props.rules,
		} as Types.Decorator.ChildEntry<N>);

		return constructor;
	};
}
```

---

src/decorators/fade.ts

```ts
// Types
import type Types from "@root/types";

// Dependencies
import { AppRegistry } from "@registries/apps";

export default function Fade(period?: number, dampeningRatio?: number) {
	return function <T extends new (...args: any[]) => {}>(ctor: T) {
		(ctor as Types.Fade.Constructor).__forge_fade = {
			period: period ?? 0.5,
			dampeningRatio: dampeningRatio ?? 0.75,
		};

		AppRegistry.forEach((groupMap) => {
			groupMap.forEach((entry) => {
				if ((entry.constructor as unknown as T) === ctor) {
					entry.fade = (ctor as Types.Fade.Constructor).__forge_fade;
				}
			});
		});

		return ctor;
	};
}
```

---

src/decorators/index.ts

```ts
export { Args, ChildArgs } from "./args";

export { default as ChildApp } from "./childApp";
export { default as Fade } from "./fade";
export { default as App } from "./app";
```

---

src/forge.ts

```ts
// Packages
import Vide, { apply, create, effect } from "@rbxts/vide";

// Types
import type Types from "@root/types";

// Classes
import Renders from "@root/renders";

// Helpers
import getAppSource from "@helpers/getAppSource";

export class AppForge extends Renders {
	constructor() {
		super();
	}

	public bind(name: AppNames, group: AppGroups = "None", value: Vide.Source<boolean>) {
		const src = getAppSource(name, group);
		if (!src) return;

		effect(() => {
			src(value());
		});
	}

	// TODO: make a separate files for rules
	public set(name: AppNames, group: AppGroups = "None", value: boolean) {
		let src = getAppSource(name, group);
		if (!src) return;

		const prev = src();
		if (prev === value) return;

		src(value);
	}

	public open(name: AppNames, group: AppGroups = "None") {
		this.set(name, group, true);
	}
	public close(name: AppNames, group: AppGroups = "None") {
		this.set(name, group, false);
	}
	public toggle(name: AppNames, group: AppGroups = "None") {
		const src = getAppSource(name, group);
		if (!src) return;

		this.set(name, group, !src());
	}

	story = ({
		props,
		target,
		renders,
		config,
	}: {
		props: AppProps;
		target: GuiObject;
		renders?: Types.Render.Props;
		config?: Types.Props.Config;
	}) => {
		const Container = create("Frame")({
			Name: "Story Container",
			BackgroundTransparency: 1,
			AnchorPoint: new Vector2(0.5, 0.5),
			Position: UDim2.fromScale(0.5, 0.5),
			Size: UDim2.fromScale(1, 1),
		});

		apply(Container as Instance)({
			[0]: this.Initialize({
				props,
				forge: this,
				renders,
				config: {
					px: {
						target,
						minScale: config?.px?.minScale,
					},
				},
			}),
		});

		this.setupRuleEffects(this);
		return Container;
	};
	render = ({ props }: { props: Omit<Types.Props.Main, "forge"> }) => {
		const instances = this.Initialize({ ...props, forge: this });
		this.setupRuleEffects(this);
		return instances;
	};
}
```

---

src/helpers/getAppEntry.ts

```ts
// Components
import { AppRegistry } from "@registries/apps";

export default function getAppEntry(name: AppNames, group: AppGroups) {
	const entryMap = AppRegistry.get(name);

	const entry = entryMap?.get(group);
	if (!entry) error(`Failed to get entry for name ${name} and group ${group}`);

	return entry;
}
```

---

src/helpers/getAppSource.ts

```ts
// Components
import { AppSources } from "@registries/apps";

export default function getAppSource(name: AppNames, group: AppGroups = "None") {
	const sourceMap = AppSources.get(name);

	const source = sourceMap?.get(group);
	if (!source)
		error(`Failed to find source for name: ${name} group: ${group} \n ${debug.traceback()}`);

	return source;
}
```

---

src/helpers/hasAppSource.ts

```ts
// Components
import { AppSources } from "@registries/apps";

export default function hasAppSource(name: AppNames, group: AppGroups) {
	const sourceMap = AppSources.get(name);
	if (!sourceMap) return false;

	const source = sourceMap?.get(group);
	if (!source) return false;

	return true;
}
```

---

src/helpers/isChildAppRules.ts

```ts
// helpers/isChild.ts
import type Types from "@root/types";

/**
 * Type guard to check if a rules object is a ChildApp (i.e., has a parent or is a child type)
 */
export default function isChildAppRules(
	rules?: Types.Rules.App | Types.Rules.ChildApp,
): rules is Types.Rules.ChildApp {
	return rules !== undefined && "parent" in rules && typeIs(rules.parent, "string");
}
```

---

src/helpers/isChildEntry.ts

```ts
// helpers/isChildEntry.ts
import type Types from "@root/types";

/**
 * Type guard to check if a registry entry is a ChildEntry
 */
export default function isChildEntry(
	entry?: Types.Decorator.Entry | Types.Decorator.ChildEntry,
): entry is Types.Decorator.ChildEntry {
	return (
		!!entry && !!entry.rules && "parent" in entry.rules && typeIs(entry.rules.parent, "string")
	);
}
```

---

src/helpers/setAppSource.ts

```ts
// Packages
import { source } from "@rbxts/vide";

// Components
import { AppSources } from "@registries/apps";

export default function setAppSource(name: AppNames, group: AppGroups, value: boolean) {
	if (!AppSources.get(name)) AppSources.set(name, new Map());

	const src = AppSources.get(name)?.get(group);
	if (!src) {
		const newSource = source(value);

		AppSources.get(name)?.set(group, newSource);
	} else {
		src(false);
	}
}
```

---

src/hooks/useAppContext.ts

```ts
// Contexts
import { AppContext } from "@root/contexts";

export default () => {
	const ctx = AppContext();
	if (!ctx) {
		error(`Failed to retrieve App Forge Context Data for Context\n${debug.traceback()}`, 2);
	}
	return ctx;
};
```

---

src/hooks/useChildAppContext.ts

```ts
// Contexts
import { ChildAppContext } from "@root/contexts";

export default () => {
	const ctx = ChildAppContext();
	if (!ctx) {
		error(`Failed to retrieve App Forge Context Data for Context\n${debug.traceback()}`, 2);
	}

	return ctx;
};
```

---

src/hooks/useEventListener.ts

```ts
// Packages
import { cleanup } from "@rbxts/vide";

type EventLike<T extends Callback = Callback> =
	| { Connect(callback: T): ConnectionLike }
	| { connect(callback: T): ConnectionLike }
	| { subscribe(callback: T): ConnectionLike };

type ConnectionLike = { Disconnect(): void } | { disconnect(): void } | (() => void);

const connect = (event: EventLike, callback: Callback): ConnectionLike => {
	if (typeIs(event, "RBXScriptSignal")) {
		const connection = event.Connect((...args: unknown[]) => {
			if (connection.Connected) {
				return callback(...args);
			}
		});
		return connection;
	} else if ("Connect" in event) {
		return event.Connect(callback);
	} else if ("connect" in event) {
		return event.connect(callback);
	} else if ("subscribe" in event) {
		return event.subscribe(callback);
	} else {
		throw "Event-like object does not have a supported connect method.";
	}
};

const disconnect = (connection: ConnectionLike) => {
	if (typeIs(connection, "function")) {
		connection();
	} else if (typeIs(connection, "RBXScriptConnection") || "Disconnect" in connection) {
		connection.Disconnect();
	} else if ("disconnect" in connection) {
		connection.disconnect();
	} else {
		throw "Connection-like object does not have a supported disconnect method.";
	}
};

/**
 * Subscribes to an event-like object. The subscription is automatically
 * disconnected when the scope cleans up.
 *
 * @param event The event-like object to subscribe to.
 * @param listener The listener to subscribe with.
 * @returns The connection object.
 */
export default function useEventListener<T extends EventLike>(
	event: T,
	listener: T extends EventLike<infer U> ? U : never,
): ReturnType<T> {
	const connection = connect(event, listener);

	cleanup(() => disconnect(connection));
	return connection as ReturnType<T>;
}
```

---

src/hooks/usePx.ts

```ts
// Services
import { Workspace } from "@rbxts/services";

// Packages
import { source } from "@rbxts/vide";

// Helpers
import useEventListener from "./useEventListener";

/** Default reference resolution for px calculations */
const BASE_RESOLUTION = source(new Vector2(1920, 1080));

/** Minimum allowed scale to prevent unreadable UI */
const MIN_SCALE = source(0.5);

/** 0 = width-based, 1 = height-based */
const DOMINANT_AXIS = 0.5;

const TARGET = source<GuiObject | Camera | undefined>(Workspace.CurrentCamera);
const SCALE = source(1);

let INITIALIZED = false;

function callable<T extends Callback, U>(callback: T, object: U): T & U {
	return setmetatable(object as never, {
		__call: (_, ...args) => callback(...args),
	});
}

export const screen = source(new Vector2(0, 0));
export const px = callable((value: number) => math.round(value * SCALE()), {
	scale: (value: number) => value * SCALE(),
	even: (value: number) => math.round(value * SCALE() * 0.5) * 2,
	floor: (value: number) => math.floor(value * SCALE()),
	ceil: (value: number) => math.ceil(value * SCALE()),
});

function calculateScale() {
	const target = TARGET();
	if (!target) return screen(new Vector2(0, 0));

	if (target.IsA("Camera")) screen(target.ViewportSize);
	else if (target.IsA("GuiObject")) screen(target.AbsoluteSize);

	const size = target.IsA("Camera")
		? target.ViewportSize
		: target.IsA("GuiObject")
			? target.AbsoluteSize
			: undefined;

	if (!size) return;

	const res = BASE_RESOLUTION();
	if (res.X <= 0 || res.Y <= 0) return;

	const min = MIN_SCALE();

	const width = math.log(size.X / res.X, 2);
	const height = math.log(size.Y / res.Y, 2);

	const centered = width + (height - width) * DOMINANT_AXIS;
	const scale = 2 ** centered;

	SCALE(math.max(scale, min));
}

/**
 * Initializes global px scaling.
 * Must be called exactly once.
 */
export function usePx(target?: GuiObject | Camera, baseResolution?: Vector2, minScale?: number) {
	if (INITIALIZED) return warn("usePx() called more than once");

	INITIALIZED = true;

	if (baseResolution) BASE_RESOLUTION(baseResolution);
	if (minScale) MIN_SCALE(minScale);
	if (target) TARGET(target);

	const resolvedTarget = TARGET();
	if (!resolvedTarget) return warn("usePx(): no valid target to observe");

	const signal = resolvedTarget.IsA("Camera")
		? resolvedTarget.GetPropertyChangedSignal("ViewportSize")
		: resolvedTarget.GetPropertyChangedSignal("AbsoluteSize");

	useEventListener(signal, calculateScale);
	calculateScale();
}
```

---

src/index.ts

```ts
// Decorators
export { App, Args, ChildApp, ChildArgs, Fade } from "@root/decorators";

// Creators
import { AppForge } from "@root/forge";

// Logger
export { default as Logger } from "@root/logger";

// Types
export type {
	ForgeProps,
	ClassProps,
	RenderProps,
} from "@root/types";

// Story
export { default as Story } from "@root/story";

export { AppContext, ChildAppContext } from "@root/contexts";
export { default as useForgeContext } from "@hooks/useAppContext";
export { default as useChildForgeContext } from "@hooks/useChildAppContext";

export default AppForge;
```

---

src/logger.ts

```ts
const PREFIX = "[Forge]";
let DEBUG = false;

const Logger = {
	/**
	 * Enable or disable debug logging.
	 * Should be called before CreateForge is instantiated.
	 */
	setDebug: (enabled: boolean) => {
		DEBUG = enabled;
	},

	/**
	 * General debug log — only prints when debug mode is enabled.
	 */
	debug: (context: string, message: string) => {
		if (!DEBUG) return;
		print(`${PREFIX}[${context}]: ${message}`);
	},

	/**
	 * Always prints a warning.
	 */
	warn: (context: string, message: string) => {
		warn(`${PREFIX}[${context}]: ${message}`);
	},

	/**
	 * Always throws an error.
	 */
	error: (context: string, message: string) => {
		error(`${PREFIX}[${context}]: ${message}`, 2);
	},

	/**
	 * Times how long a render function takes and logs it if debug is enabled.
	 * Returns whatever the callback returns.
	 */
	time: <T>(context: string, name: string, fn: () => T): T => {
		if (!DEBUG) return fn();
		const start = os.clock();
		const result = fn();
		const elapsed = os.clock() - start;
		print(`${PREFIX}[${context}]: "${name}" rendered in ${string.format("%.4f", elapsed)}s`);
		return result;
	},
};

export default Logger;
```

---

src/managers/rules/checks/parent.ts

```ts
// Types
import type { AppForge } from "@root/forge";

// Packages
import { batch } from "@rbxts/vide";

// Helpers
import getAppSource from "@helpers/getAppSource";
import isChildEntry from "@helpers/isChildEntry";
import getAppEntry from "@helpers/getAppEntry";

// Registries
import { AppRegistry } from "@registries/apps";

const cache = new Map<string, boolean>();
const cachedOnClose = new Set<string>();
const closingParents = new Set<string>();

export default function ParentRule(forge: AppForge, name: AppNames, group: AppGroups) {
	const entry = getAppEntry(name, group);
	if (!entry) return;

	const isVisible = getAppSource(name, group)();
	const key = `${name}:${group}`;

	if (isChildEntry(entry)) {
		const parentName = entry.rules.parent;
		const parentGroup = entry.rules.parentGroup ?? "None";
		const parentKey = `${parentName}:${parentGroup}`;
		const parentVisible = getAppSource(parentName, parentGroup)();

		if (!parentVisible && !closingParents.has(parentKey)) cache.set(key, isVisible);
	} else {
		if (!isVisible) {
			if (closingParents.has(key) || cachedOnClose.has(key)) return;

			cachedOnClose.add(key);
			AppRegistry.forEach((entryMap) => {
				entryMap.forEach((childEntry, childGroup) => {
					if (!isChildEntry(childEntry)) return;
					if (childEntry.rules.parent !== name) return;
					if ((childEntry.rules.parentGroup ?? "None") !== group) return;

					const childKey = `${childEntry.name}:${childGroup}`;
					const childVisible = getAppSource(childEntry.name, childGroup)();

					cache.set(childKey, childVisible);
				});
			});

			closingParents.add(key);
			batch(() => {
				AppRegistry.forEach((entryMap) => {
					entryMap.forEach((childEntry, childGroup) => {
						if (!isChildEntry(childEntry)) return;
						if (childEntry.rules.parent !== name) return;
						if ((childEntry.rules.parentGroup ?? "None") !== group) return;

						forge.close(childEntry.name, childGroup);
					});
				});
			});
			closingParents.delete(key);
		} else {
			cachedOnClose.delete(key);

			AppRegistry.forEach((entryMap) => {
				entryMap.forEach((childEntry, childGroup) => {
					if (!isChildEntry(childEntry)) return;
					if (childEntry.rules.parent !== name) return;
					if ((childEntry.rules.parentGroup ?? "None") !== group) return;

					const childKey = `${childEntry.name}:${childGroup}`;
					const cached = cache.get(childKey);

					forge.set(childEntry.name, childGroup, cached ?? false);
				});
			});
		}
	}
}
```

---

src/managers/rules/index.ts

```ts
// Packages
import { effect, untrack } from "@rbxts/vide";

// Types
import type { AppForge } from "@root/forge";

// Rules
import ParentRule from "./checks/parent";

// Components
import { AppRegistry } from "@registries/apps";

// Helpers
import hasAppSource from "@helpers/hasAppSource";
import getAppSource from "@helpers/getAppSource";

export default class Rules {
	protected processing = new Set<string>();

	protected setupRuleEffects(forge: AppForge) {
		AppRegistry.forEach((entryMap, name) => {
			entryMap.forEach((_, group) => {
				if (!hasAppSource(name, group)) return;
				effect(() => {
					getAppSource(name, group)();
					untrack(() => this.checkRules(forge, name, group));
				});
			});
		});
	}

	protected checkRules(forge: AppForge, name: AppNames, group: AppGroups) {
		const key = `${name}:${group}`;
		if (this.processing.has(key)) return;
		this.processing.add(key);
		try {
			ParentRule(forge, name, group);
		} finally {
			this.processing.delete(key);
		}
	}
}
```

---

src/registries/apps.ts

```ts
// Packages
import { Source } from "@rbxts/vide";

// Types
import type Types from "@root/types";

export type RegistryMap<N> = Map<AppNames, Map<AppGroups, N>>;
export type AnyAppEntry<N extends AppNames = AppNames> =
	| Types.Decorator.Entry<N>
	| Types.Decorator.ChildEntry<N>;

export const AppRegistry: RegistryMap<AnyAppEntry> = new Map();
export const AppSources: RegistryMap<Source<boolean>> = new Map();
```

---

src/renders/createAnchor.ts

```ts
// Packages
import { apply } from "@rbxts/vide";

// Types
import type Types from "@root/types";

// Helpers
import getAppEntry from "@helpers/getAppEntry";

export default function createAnchor(
	entry: Types.Decorator.ChildEntry,
	props: Types.Props.Main,
	entryInstance: Instance,
	Loaded: Map<AppNames, Map<AppGroups, { instance: Instance }>>,
): Instance | undefined {
	const parentName = entry.rules.parent;
	const parentGroup = entry.rules.parentGroup ?? "None";
	const parentEntry = getAppEntry(parentName, parentGroup);
	const anchor = new parentEntry.constructor(parentEntry as never, props).render() as GuiObject;

	// Clear Descendants
	anchor.GetDescendants().forEach((instance) => instance.Destroy());

	if (!entryInstance) {
		const loaded = Loaded.get(entry.name)?.get(entry.group ?? "None");
		if (loaded) {
			entryInstance = loaded.instance;
		} else {
			warn("Failed to get Instance for Anchor");
			return;
		}
	}

	apply(anchor)({
		Name: "Anchor",
		BackgroundTransparency: 1,
		[0]: entryInstance,
	});

	return anchor;
}
```

---

src/renders/createInstance.tsx

```ts
// Packages
import Vide, { spring } from "@rbxts/vide";
// Types
import type Types from "@root/types";
// Components
import FadeComponent from "@components/fade";
// Helpers
import isChildAppRules from "@helpers/isChildAppRules";
import isChildEntry from "@helpers/isChildEntry";
import getAppSource from "@helpers/getAppSource";
import getAppEntry from "@helpers/getAppEntry";
// Renders
import createAnchor from "./createAnchor";
// Logger
import Logger from "@root/logger";

type Render = {
	instance: Instance;
	container: Instance;
	anchor: Instance | undefined;
	entry: Types.Decorator.Entry | Types.Decorator.ChildEntry;
};

export default function createInstance(
	props: Types.Props.Main,
	name: AppNames,
	group: AppGroups,
	childContainers: Instance[],
	Loaded: Map<AppNames, Map<AppGroups, Render>>,
): Render | undefined {
	const entry = getAppEntry(name, group);
	if (!entry) return;

	let entryInstance: Instance;
	let anchor: Instance | undefined;
	let parentContainer: Instance | undefined;

	if (isChildEntry(entry)) {
		// Time the child app render
		entryInstance = Logger.time(
			"Renders",
			`${group}:${name}`,
			() => new entry.constructor(entry as never, props).render() as Instance,
		);

		const parentGroup = entry.rules.parentGroup ?? "None";
		const parentMap = Loaded.get(entry.rules.parent);
		if (parentMap) {
			const parentEntry = parentMap.get(parentGroup);
			if (parentEntry) parentContainer = parentEntry.container;
		}

		if (entry.rules.anchor) {
			anchor = createAnchor(entry, props, entryInstance, Loaded);
		}
	} else {
		// Time the root app render
		entryInstance = Logger.time(
			"Renders",
			`${group}:${name}`,
			() => new entry.constructor(entry as never, props).render() as Instance,
		);
	}

	entryInstance.Name = "Render";

	const zIndex = isChildAppRules(entry.rules) ? (entry.zIndex ?? 0) : (entry.zIndex ?? 1);

	let container: Instance;

	if (entry.fade) {
		const source = getAppSource(name, group);
		container = (
			<FadeComponent
				name={`${group}_${name}_Container`}
				groupTransparency={
					spring(() => (source() ? 0 : 1), entry.fade.period, entry.fade.dampeningRatio)[0]
				}
				anchor={new Vector2(0.5, 0.5)}
				position={UDim2.fromScale(0.5, 0.5)}
				size={UDim2.fromScale(1, 1)}
				parent={parentContainer}
				zIndex={zIndex}
			>
				{anchor ?? entryInstance}
				{...childContainers}
			</FadeComponent>
		) as Instance;
	} else {
		container = (
			<frame
				Name={`${group}_${name}_Container`}
				BackgroundTransparency={1}
				AnchorPoint={new Vector2(0.5, 0.5)}
				Position={UDim2.fromScale(0.5, 0.5)}
				Size={UDim2.fromScale(1, 1)}
				Parent={parentContainer}
				ZIndex={zIndex}
			>
				{anchor ?? entryInstance}
				{...childContainers}
			</frame>
		) as Instance;
	}

	const render: Render = { container, instance: entryInstance, entry, anchor };
	const newMap = new Map<AppGroups, Render>();
	newMap.set(group, render);
	Loaded.set(name, newMap);

	return render;
}

export type { Render };
```

---

src/renders/index.ts

```ts
// Services
import { Workspace } from "@rbxts/services";
// Types
import type Types from "@root/types";
// Components
import { AppRegistry } from "@registries/apps";
// Hooks
import { usePx } from "@hooks/usePx";
// Classes
import Rules from "@managers/rules";
// Helpers
import isChildAppRules from "@helpers/isChildAppRules";
import isChildEntry from "@helpers/isChildEntry";
import getAppEntry from "@helpers/getAppEntry";
import hasAppSource from "@helpers/hasAppSource";
import setAppSource from "@helpers/setAppSource";
// Renders
import createInstance, { type Render } from "./createInstance";
// Logger
import Logger from "@root/logger";

export default class Renders extends Rules {
	protected Loaded = new Map<AppNames, Map<AppGroups, Render>>();
	private __initalize = false;

	constructor() {
		super();
	}

	protected Initialize(props: Types.Props.Main) {
		if (!this.__initalize) {
			usePx(
				props.config?.px?.target || Workspace.CurrentCamera,
				props.config?.px?.resolution,
				props.config?.px?.minScale,
			);
			this.__initalize = true;
		}
		return this.Load(props);
	}

	private Load(props: Types.Props.Main) {
		const renders = props.renders;

		const names =
			renders?.name !== undefined
				? new Set([renders.name])
				: renders?.names !== undefined
					? new Set(renders.names)
					: undefined;

		const groups =
			renders?.group !== undefined
				? new Set([renders.group])
				: renders?.groups !== undefined
					? new Set(renders.groups)
					: undefined;

		const load: Instance[] = [];
		const rendered = new Set<string>();

		// Time the entire load pass
		const start = os.clock();

		const renderEntry = (name: AppNames, group: AppGroups): Instance | undefined => {
			const key = `${name}:${group}`;
			if (rendered.has(key)) return;
			rendered.add(key);

			// Create source for this app if it doesn't exist yet
			if (!hasAppSource(name, group)) {
				const entry = getAppEntry(name, group);
				setAppSource(name, group, entry.visible ?? false);
			}

			// Collect all direct child containers before building this container
			const childContainers: Instance[] = [];
			AppRegistry.forEach((groupEntries) => {
				groupEntries.forEach((childEntry, childGroup) => {
					if (!isChildEntry(childEntry)) return;
					if (childEntry.rules.parent !== name) return;
					const childParentGroup = childEntry.rules.parentGroup ?? "None";
					if (childParentGroup !== group) return;
					const childContainer = renderEntry(childEntry.name, childGroup);
					if (childContainer) childContainers.push(childContainer);
				});
			});

			const render = createInstance(props, name, group, childContainers, this.Loaded);
			if (!render) return;

			if (!isChildAppRules(getAppEntry(name, group)?.rules)) {
				load.push(render.container);
			}

			return render.container;
		};

		AppRegistry.forEach((groupEntries, appName) => {
			groupEntries.forEach((entry, group) => {
				if (isChildEntry(entry)) return;
				if (names && !names.has(appName)) return;
				if (groups && !groups.has(group)) return;
				renderEntry(appName, group);
			});
		});

		const elapsed = os.clock() - start;
		Logger.debug(
			"Renders",
			`Load completed in ${string.format("%.4f", elapsed)}s — ${rendered.size()} app(s) rendered`,
		);

		return load;
	}
}
```

---

src/story.tsx

```ts
// Packages
import { AppForge } from "@root/forge";
import Vide from "@rbxts/vide";

// Types
import type Types from "@root/types";

export default function Story({
	props,
	target,
	render,
	callback,
}: {
	props: AppProps;
	target: GuiObject;
	render?: Types.Render.Props;
	callback?: (props: AppProps, Forge: AppForge) => void;
}) {
	const forge = new AppForge();
	const rendered = <forge.story props={props} target={target} renders={render} />;

	if (callback) callback(props, forge);

	return rendered;
}
```

---

src/types/global.d.ts

```ts
// Packages
import type { Node } from "@rbxts/vide";

declare global {
	// These will be overridden by the user
	// They are only placeholders for your build
	type AppGroups = string;
	type AppNames = string;
	type AppProps = {};

	// HELPERS FOR AUTOCOMPLETION TYPES
	namespace AppForge {
		type AppNode = Node;
	}
}
export {};
```

---

src/types/index.d.ts

```ts
// Types
import type { Args, ChildArgs } from "@root/decorators";
import type { AppForge } from "@root/forge";

declare namespace Types {
	/* =======================
	 * Props
	 * ======================= */
	namespace Render {
		type NameSelector = { name: AppNames; names?: never } | { names: AppNames[]; name?: never };
		type GroupSelector =
			| { group: AppGroups; groups?: never }
			| { groups: AppGroups[]; group?: never };

		type NameOnly = { name: AppNames; names?: never; group?: never; groups?: never };
		type NamesOnly = { names: AppNames[]; name?: never; group?: never; groups?: never };
		type GroupOnly = { group: AppGroups; groups?: never; name?: never; names?: never };
		type GroupsOnly = { groups: AppGroups[]; group?: never; name?: never; names?: never };
		type NameAndGroup = { name: AppNames; names?: never; group: AppGroups; groups?: never };
		type NameAndGroups = { name: AppNames; names?: never; groups: AppGroups[]; group?: never };
		type NamesAndGroup = { names: AppNames[]; name?: never; group: AppGroups; groups?: never };
		type NamesAndGroups = { names: AppNames[]; name?: never; groups: AppGroups[]; group?: never };

		export type Props =
			| NameOnly
			| NamesOnly
			| GroupOnly
			| GroupsOnly
			| NameAndGroup
			| NameAndGroups
			| NamesAndGroup
			| NamesAndGroups;
	}

	/* =======================
	 * Props
	 * ======================= */
	namespace Props {
		export type Main = {
			props: AppProps;
			forge: AppForge;
			config?: Config;
			renders?: Render.Props;
		};

		export type Config = {
			px?: {
				target?: GuiObject | Camera;
				resolution?: Vector2;
				minScale?: number;
			};
		};

		export type Class = AppProps & {
			screen: typeof import("../hooks/usePx").screen;
			px: typeof import("../hooks/usePx").px;
		};
	}

	/* =======================
	 * Rules
	 * ======================= */
	namespace Rules {
		type WithParent<P extends AppNames = AppNames> = {
			parent: P;
			parentGroup?: AppGroups;
			anchor?: boolean;
		};

		export type App = {};

		export type ChildApp = {} & WithParent;
	}

	/* =======================
	 * App Registry
	 * ======================= */
	namespace Fade {
		export type Config = {
			period?: number;
			dampeningRatio?: number;
		};

		export type Constructor = {
			__forge_fade?: Fade.Config;
		};
	}

	/* =======================
	 * App Registry
	 * ======================= */
	namespace Decorator {
		export type Constructor<N extends AppNames = AppNames> = new (
			entry: Entry<N>,
			props: Props.Main,
		) => Args;

		export type ChildConstructor<N extends AppNames = AppNames> = new (
			entry: ChildEntry<N>,
			props: Props.Main,
		) => ChildArgs;

		export type Entry<N extends AppNames = AppNames> = {
			constructor: Constructor<N>;
			name: AppNames;
			group?: AppGroups;
			visible?: boolean;
			zIndex?: number;

			rules?: Rules.App;
			fade?: Fade.Config;
		};

		export type ChildEntry<N extends AppNames = AppNames> = {
			constructor: ChildConstructor<N>;
			name: AppNames;
			group?: AppGroups;
			visible?: boolean;
			zIndex?: number;

			rules: Rules.ChildApp;
			fade?: Fade.Config;
		};

		export type AppProps<N extends AppNames = AppNames> = {
			name: N;
			group?: AppGroups;
			visible?: boolean;
			zIndex?: number;

			rules?: Rules.App;
		};
		export type ChildAppProps<N extends AppNames = AppNames> = {
			name: N;
			group?: AppGroups;
			visible?: boolean;
			zIndex?: number;

			rules: Rules.ChildApp;
		};
	}
}

export type ForgeProps = Types.Props.Main;
export type ClassProps = Types.Props.Class;
export type RenderProps = Types.Render.Props;

export default Types;
```

---

src/types/references.d.ts

```ts
/// <reference path="./global.d.ts" />
```

---

